import{r as A}from"./main-Bxfe4Qal.js";import{a as m,r as S}from"./AlertProvider-CS83QDva.js";function w(e){const t=new Uint8Array(e);let n="";for(const a of t)n+=String.fromCharCode(a);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function O(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,r=t.padEnd(t.length+n,"="),a=atob(r),i=new ArrayBuffer(a.length),c=new Uint8Array(i);for(let o=0;o<a.length;o++)c[o]=a.charCodeAt(o);return i}function _(){return U.stubThis((globalThis==null?void 0:globalThis.PublicKeyCredential)!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const U={stubThis:e=>e};function C(e){const{id:t}=e;return{...e,id:O(t),transports:e.transports}}function N(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class l extends Error{constructor({message:t,code:n,cause:r,name:a}){super(t,{cause:r}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=a??r.name,this.code=n}}function L({error:e,options:t}){var r,a,i;const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new l({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((r=n.authenticatorSelection)==null?void 0:r.requireResidentKey)===!0)return new l({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&((a=n.authenticatorSelection)==null?void 0:a.userVerification)==="required")return new l({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(((i=n.authenticatorSelection)==null?void 0:i.userVerification)==="required")return new l({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new l({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new l({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new l({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new l({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const c=globalThis.location.hostname;if(N(c)){if(n.rp.id!==c)return new l({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new l({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new l({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new l({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class x{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const D=new x,H=["cross-platform","platform"];function v(e){if(e&&!(H.indexOf(e)<0))return e}async function B(e){var y;!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:n=!1}=e;if(!_())throw new Error("WebAuthn is not supported in this browser");const r={...t,challenge:O(t.challenge),user:{...t.user,id:O(t.user.id)},excludeCredentials:(y=t.excludeCredentials)==null?void 0:y.map(C)},a={};n&&(a.mediation="conditional"),a.publicKey=r,a.signal=D.createNewAbortSignal();let i;try{i=await navigator.credentials.create(a)}catch(u){throw L({error:u,options:a})}if(!i)throw new Error("Registration was not completed");const{id:c,rawId:o,response:d,type:E}=i;let p;typeof d.getTransports=="function"&&(p=d.getTransports());let R;if(typeof d.getPublicKeyAlgorithm=="function")try{R=d.getPublicKeyAlgorithm()}catch(u){T("getPublicKeyAlgorithm()",u)}let g;if(typeof d.getPublicKey=="function")try{const u=d.getPublicKey();u!==null&&(g=w(u))}catch(u){T("getPublicKey()",u)}let b;if(typeof d.getAuthenticatorData=="function")try{b=w(d.getAuthenticatorData())}catch(u){T("getAuthenticatorData()",u)}return{id:c,rawId:w(o),response:{attestationObject:w(d.attestationObject),clientDataJSON:w(d.clientDataJSON),transports:p,publicKeyAlgorithm:R,publicKey:g,authenticatorData:b},type:E,clientExtensionResults:i.getClientExtensionResults(),authenticatorAttachment:v(i.authenticatorAttachment)}}function T(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function W(){if(!_())return I.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return(e==null?void 0:e.isConditionalMediationAvailable)===void 0?I.stubThis(new Promise(t=>t(!1))):I.stubThis(e.isConditionalMediationAvailable())}const I={stubThis:e=>e};function M({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new l({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new l({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const r=globalThis.location.hostname;if(N(r)){if(n.rpId!==r)return new l({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new l({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new l({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function J(e){var b,y;!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:n=!1,verifyBrowserAutofillInput:r=!0}=e;if(!_())throw new Error("WebAuthn is not supported in this browser");let a;((b=t.allowCredentials)==null?void 0:b.length)!==0&&(a=(y=t.allowCredentials)==null?void 0:y.map(C));const i={...t,challenge:O(t.challenge),allowCredentials:a},c={};if(n){if(!await W())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&r)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');c.mediation="conditional",i.allowCredentials=[]}c.publicKey=i,c.signal=D.createNewAbortSignal();let o;try{o=await navigator.credentials.get(c)}catch(u){throw M({error:u,options:c})}if(!o)throw new Error("Authentication was not completed");const{id:d,rawId:E,response:p,type:R}=o;let g;return p.userHandle&&(g=w(p.userHandle)),{id:d,rawId:w(E),response:{authenticatorData:w(p.authenticatorData),clientDataJSON:w(p.clientDataJSON),signature:w(p.signature),userHandle:g},type:R,clientExtensionResults:o.getClientExtensionResults(),authenticatorAttachment:v(o.authenticatorAttachment)}}const $=()=>{const[e,t]=A.useState(!1),[n,r]=A.useState(null),[a,i]=A.useState(null),[c,o]=A.useState([]),[d,E]=A.useState(!1),[p,R]=A.useState(null),g=()=>({"Content-Type":"application/json",Authorization:`Bearer ${localStorage.getItem("authToken")}`}),b=async()=>{E(!0),r(null);try{const s=await m.get(S.passkeyRoutes.list,{headers:g(),withCredentials:!0});o(s.data)}catch(s){console.error("Error fetching passkeys:",s),r("Failed to load passkeys")}finally{E(!1)}},y=async s=>{var f;R(s);try{await m.delete(`${S.passkeyRoutes.base}/${s}`,{headers:g(),withCredentials:!0}),o(c.filter(h=>h.id!==s))}catch(h){throw typeof h=="object"&&h!==null&&"response"in h&&h.response?new Error(((f=h.response.data)==null?void 0:f.message)||"Error deleting passkey"):h}finally{R(null)}},u=async s=>{t(!0),i(null);try{const{data:f}=await m.post(S.passkeyRoutes.generateRegistrationOptions,s?{email:s}:{},{headers:g(),withCredentials:!0}),h=await B({optionsJSON:f}),P=await m.post(S.passkeyRoutes.verifyRegistration,h,{headers:g(),withCredentials:!0});if(!P.data.verified)throw new Error("Passkey registration failed");return s||await b(),P.data}catch(f){throw f&&typeof f=="object"&&"message"in f?i(f.message||"Failed to register passkey"):i("Failed to register passkey"),f}finally{t(!1)}},k=async()=>{t(!0),r(null);try{const{data:s}=await m.post(S.passkeyRoutes.generateAuthenticationOptions,{},{withCredentials:!0}),f=await J({optionsJSON:s}),h=await m.post(S.passkeyRoutes.verifyAuthentication,f,{headers:{"Content-Type":"application/json"},withCredentials:!0});if(!h.data.verified)throw new Error("Passkey authentication failed");return h.data}catch(s){throw s&&typeof s=="object"&&"message"in s?r(s.message||"Failed to login with passkey"):r("Failed to login with passkey"),s}finally{t(!1)}},K=_();return{registerPasskey:u,loginWithPasskey:k,fetchPasskeys:b,deletePasskey:y,browserSupport:K,passkeys:c,isLoading:e,loadingPasskeys:d,deleteLoading:p,error:n,registrationError:a}};export{$ as u};
